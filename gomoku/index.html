<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
<title>Unendliches 5-Gewinnt ‚Äî Person vs KI</title>
<style>
  :root{
    --bg:#f7f7f8;
    --grid:#c0c6cc;
    --line:#8f98a0;
    --black:#111;
    --white:#fff;
    --accent:#2b7cff;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#111;background:var(--bg);}
  #app{display:flex;flex-direction:column;height:100vh;}
  header{padding:10px 14px;display:flex;align-items:center;gap:10px;background:white;box-shadow:0 1px 0 rgba(0,0,0,0.05);}
  header h1{font-size:16px;margin:0;}
  .controls{display:flex;gap:8px;margin-left:auto;align-items:center;}
  button, .btn{background:var(--accent);color:white;border:none;padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer;}
  button.secondary{background:white;color:var(--accent);border:1px solid #d6e3ff;}
  #board-wrap{flex:1;display:flex;align-items:center;justify-content:center;padding:10px;touch-action:none;}
  canvas{background:linear-gradient(180deg,#f8fbff,#f7f7f8);border-radius:10px;box-shadow:0 6px 20px rgba(10,20,40,0.06);}
  .toolbar{display:flex;gap:8px;padding:10px;background:white;border-top:1px solid #eee;align-items:center;}
  .small{font-size:13px;padding:6px 8px;border-radius:8px;}
  .info{font-size:13px;color:#444;margin-left:8px;}
  .moves{display:flex;gap:6px;flex-wrap:wrap}
  .pan-btn{background:#fff;border:1px solid #eee;padding:8px;border-radius:6px}
  .legend{display:flex;gap:8px;align-items:center}
  @media (max-width:520px){
    header h1{font-size:14px}
    button{padding:7px 9px}
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>5 wins</h1>
    <div class="controls">
      <button id="new" class="btn">Neues Spiel</button>
      <button id="undo" class="secondary small">R√ºckg√§ngig</button>
      <label style="margin-left:8px;font-size:13px;">Schwierigkeit:
        <select id="difficulty" style="margin-left:6px;">
          <option value="easy">Einfach</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hart</option>
        </select>
      </label>
    </div>
  </header>

  <div id="board-wrap">
    <canvas id="board" width="820" height="820"></canvas>
  </div>

  <div class="toolbar">
    <div class="pan">
      <button class="pan-btn" data-dx="0" data-dy="-1">‚Üë</button>
      <button class="pan-btn" data-dx="-1" data-dy="0">‚Üê</button>
      <button class="pan-btn" data-dx="1" data-dy="0">‚Üí</button>
      <button class="pan-btn" data-dx="0" data-dy="1">‚Üì</button>
      <button class="pan-btn" id="center">Zentrieren</button>
    </div>
    <div style="width:20px"></div>
    <div class="legend">
      <div style="display:flex;align-items:center;gap:6px">
        <div style="width:18px;height:18px;border-radius:9px;background:#111;border:1px solid rgba(0,0,0,0.1)"></div><div class="info">Du (Schwarz)</div>
      </div>
      <div style="display:flex;align-items:center;gap:6px">
        <div style="width:18px;height:18px;border-radius:9px;background:#fff;border:1px solid #ccc"></div><div class="info">KI (Wei√ü)</div>
      </div>
    </div>
    <div style="margin-left:auto" class="info" id="status">Tippe, um zu starten</div>
  </div>
</div>

<script>
/*
  Unendliches 5-Gewinnt (Gomoku-like) ‚Äî Person vs Computer
  - Uses a Map keyed by "x,y" to allow arbitrarily large boards.
  - Viewport is NxN cells (variable by canvas size / cell size).
  - Drag to pan (touch/mouse). Buttons to pan too.
  - AI: immediate win/block; otherwise heuristic scoring of candidates
         near existing stones (within radius).
*/

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha: false });
let cellSize = 44;             // size of one cell in px
let gridSize = 15;             // number of cells visible per row/col (we will compute from canvas but keep odd)
let halfView = 7;              // around center
let offsetX = 0, offsetY = 0;  // center coordinate (grid coord at canvas center)
let dragStart = null;
let lastMouse = null;

const statusEl = document.getElementById('status');
const difficultyEl = document.getElementById('difficulty');

let board = new Map(); // "x,y" => 1 (black=player) or -1 (white=ai)
let moves = []; // history [{x,y,player}]
let currentPlayer = 1; // person starts (1 = black person, -1 = white AI)
let gameOver = false;

function key(x,y){return x+','+y;}
function parseKey(k){const [a,b]=k.split(',');return {x:+a,y:+b};}

function resetGame(){
  board.clear(); moves = []; gameOver = false; currentPlayer = 1;
  offsetX = 0; offsetY = 0;
  status('Dein Zug ‚Äî tippe ein Feld');
  draw();
}

function status(t){ statusEl.textContent = t; }

function setStone(x,y,player,record=true){
  board.set(key(x,y), player);
  if(record) moves.push({x,y,player});
}

function undo(){
  if(moves.length===0) return;
  // undo last two moves (AI + player) if possible
  const last = moves.pop();
  board.delete(key(last.x,last.y));
  if(moves.length>0 && last.player===-1 && moves[moves.length-1].player===1){
    // undo player's previous too (so it feels like "undo my last move")
    const pl = moves.pop();
    board.delete(key(pl.x,pl.y));
  }
  gameOver=false;
  status('R√ºckg√§ngig ‚Äî dein Zug');
  draw();
}

// drawing
function computeViewport(){
  // compute number of cells that fit
  const w = canvas.width, h = canvas.height;
  gridSizeX = Math.floor(w / cellSize);
  gridSizeY = Math.floor(h / cellSize);
  // ensure odd to have exact center
  gridSizeX += (gridSizeX%2===0)?-1:0;
  gridSizeY += (gridSizeY%2===0)?-1:0;
  halfX = Math.floor(gridSizeX/2);
  halfY = Math.floor(gridSizeY/2);
}

function draw(){
  computeViewport();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle = '#f8fbff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const startX = offsetX - halfX;
  const startY = offsetY - halfY;

  // draw grid
  ctx.strokeStyle = '#bfc7cf';
  ctx.lineWidth = 1;
  for(let i=0;i<=gridSizeX;i++){
    const x = i*cellSize + (canvas.width - gridSizeX*cellSize)/2;
    ctx.beginPath(); ctx.moveTo(x, (canvas.height - gridSizeY*cellSize)/2); ctx.lineTo(x, (canvas.height + gridSizeY*cellSize)/2); ctx.stroke();
  }
  for(let j=0;j<=gridSizeY;j++){
    const y = j*cellSize + (canvas.height - gridSizeY*cellSize)/2;
    ctx.beginPath(); ctx.moveTo((canvas.width - gridSizeX*cellSize)/2, y); ctx.lineTo((canvas.width + gridSizeX*cellSize)/2, y); ctx.stroke();
  }

  // draw coordinates lightly (optional small)
  // draw stones
  for(let gx = startX; gx <= offsetX + halfX; gx++){
    for(let gy = startY; gy <= offsetY + halfY; gy++){
      const k = key(gx,gy);
      if(board.has(k)){
        const player = board.get(k);
        const cx = ( (gx - startX) + 0.5) * cellSize + (canvas.width - gridSizeX*cellSize)/2;
        const cy = ( (gy - startY) + 0.5) * cellSize + (canvas.height - gridSizeY*cellSize)/2;
        drawStone(cx, cy, player);
      }
    }
  }

  // draw last move highlight
  if(moves.length>0){
    const last = moves[moves.length-1];
    if(Math.abs(last.x - offsetX) <= halfX && Math.abs(last.y - offsetY) <= halfY){
      const cx = ((last.x - startX)+0.5)*cellSize + (canvas.width - gridSizeX*cellSize)/2;
      const cy = ((last.y - startY)+0.5)*cellSize + (canvas.height - gridSizeY*cellSize)/2;
      ctx.strokeStyle = '#ffcf66';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(cx,cy,cellSize*0.36,0,Math.PI*2);
      ctx.stroke();
    }
  }
}

function drawStone(cx,cy,player){
    const r = cellSize*0.36;
  // shadow / simple
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx+1,cy+2,r+1,0,Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.fill();
  ctx.closePath();
  // stone
  ctx.beginPath();
  ctx.arc(cx,cy,r,0,Math.PI*2);
  if(player===1){
    // black
    const g = ctx.createRadialGradient(cx-calcOffset(),cy-calcOffset(),r*0.1,cx,cy,r);
    g.addColorStop(0,'#333');
    g.addColorStop(1,'#000');
    ctx.fillStyle = g;
  } else {
    const g = ctx.createRadialGradient(cx-calcOffset(),cy-calcOffset(),r*0.1,cx,cy,r);
    g.addColorStop(0,'#ffffff');
    g.addColorStop(1,'#e6e9ec');
    ctx.fillStyle = g;
    ctx.strokeStyle = '#cfcfcf';
    ctx.lineWidth = 1;
  }
  ctx.fill();
  if(player===-1) ctx.stroke();
  ctx.restore();

  function calcOffset(){ return Math.max(1, r*0.15); }
}

// coordinate conversion
function screenToCell(clientX,clientY){
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  computeViewport();
  const startX = offsetX - halfX;
  const startY = offsetY - halfY;
  const gridLeft = (canvas.width - gridSizeX*cellSize)/2;
  const gridTop  = (canvas.height - gridSizeY*cellSize)/2;
  const gx = Math.floor((x - gridLeft) / cellSize) + startX;
  const gy = Math.floor((y - gridTop) / cellSize) + startY;
  return {x:gx,y:gy};
}

// interaction
canvas.addEventListener('pointerdown', e=>{
  canvas.setPointerCapture(e.pointerId);
  dragStart = {x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY};
  lastMouse = {x:e.clientX,y:e.clientY};
});

canvas.addEventListener('pointermove', e=>{
  if(!dragStart) return;
  const dx = e.clientX - dragStart.x;
  const dy = e.clientY - dragStart.y;
  // convert pixel drag to cell shift
  const shiftX = -Math.round(dx / cellSize);
  const shiftY = -Math.round(dy / cellSize);
  offsetX = dragStart.ox + shiftX;
  offsetY = dragStart.oy + shiftY;
  draw();
});

canvas.addEventListener('pointerup', e=>{
  canvas.releasePointerCapture(e.pointerId);
  if(!dragStart){ return; }
  const moved = Math.hypot(e.clientX - dragStart.x, e.clientY - dragStart.y) > 6;
  if(!moved){
    // treat as click
    const c = screenToCell(e.clientX, e.clientY);
    handlePlayerMove(c.x, c.y);
  }
  dragStart = null;
  draw();
});

// support touch double-tap / mobile: prevent context menu
canvas.addEventListener('contextmenu', e=>e.preventDefault());

function handlePlayerMove(x,y){
  if(gameOver){ status('Spiel vorbei ‚Äî neues Spiel starten'); return; }
  const k = key(x,y);
  if(board.has(k)) { status('Feld besetzt'); return; }
  setStone(x,y,1,true);
  draw();
  if(checkWin(x,y,1)){
    gameOver = true; status('Gewonnen! üéâ'); return;
  }
 
  currentPlayer = -1;
  status('thinking...');
  setTimeout(()=>{ aiMove(); }, 70);
}

// AI logic
function aiMove(){
  if(gameOver) return;
  const difficulty = difficultyEl.value; // easy / normal / hard
  // candidate positions: empty cells within radius R of any existing stone
  const R = difficulty==='easy'?2: difficulty==='normal'?3:4;
  const candidates = new Set();
  if(board.size === 0){
    // first move: play center (0,0)
    setStone(0,0,-1,true); checkAfterAi(0,0); return;
  }
  for(const k of board.keys()){
    const p = parseKey(k);
    for(let dx=-R; dx<=R; dx++){
      for(let dy=-R; dy<=R; dy++){
        const nx = p.x + dx, ny = p.y + dy;
        const kk = key(nx,ny);
        if(!board.has(kk)) candidates.add(kk);
      }
    }
  }
  // helper: immediate win / block
  // check for immediate winning move for AI
  for(const kk of candidates){
    const {x,y} = parseKey(kk);
    // test placing for AI
    board.set(kk,-1);
    const win = checkWin(x,y,-1,true);
    board.delete(kk);
    if(win){
      setStone(x,y,-1,true); checkAfterAi(x,y); return;
    }
  }
  // check immediate block (player)
  for(const kk of candidates){
    const {x,y} = parseKey(kk);
    board.set(kk,1);
    const win = checkWin(x,y,1,true);
    board.delete(kk);
    if(win){
      setStone(x,y,-1,true); checkAfterAi(x,y); return;
    }
  }

  // score candidates
  let best = null;
  let bestScore = -Infinity;
  for(const kk of candidates){
    const {x,y} = parseKey(kk);
    const score = evaluateCell(x,y,difficulty);
    if(score > bestScore){
      bestScore = score; best = {x,y,score};
    }
  }
  if(!best){
    // fallback: random near last move
    const last = moves[moves.length-1] || {x:0,y:0};
    const nx = last.x + (Math.random()*3|0)-1;
    const ny = last.y + (Math.random()*3|0)-1;
    setStone(nx,ny,-1,true); checkAfterAi(nx,ny); return;
  }
  setStone(best.x,best.y,-1,true);
  checkAfterAi(best.x,best.y);
}

function checkAfterAi(x,y){
  draw();
  if(checkWin(x,y,-1)){
    gameOver = true; status('KI hat gewonnen ‚Äî leider.'); return;
  }
  currentPlayer = 1;
  status('Dein Zug');
}

// check win: whether placing at x,y by player yields five in a row
function checkWin(x,y,player,shortCircuit=false){
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let cnt = 1;
    // forward
    for(let s=1;s<100;s++){
      if(board.get(key(x+dx*s,y+dy*s))===player) cnt++; else break;
    }
    // backward
    for(let s=1;s<100;s++){
      if(board.get(key(x-dx*s,y-dy*s))===player) cnt++; else break;
    }
    if(cnt>=5) return true;
  }
  return false;
}

// heuristic evaluation for candidate cell
function evaluateCell(x,y,difficulty){
  // score patterns for both sides; give more weight to blocking/creating open sequences
  const me = -1; const opp = 1;
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  let score = 0;
  for(const [dx,dy] of dirs){
    const lineMe = countLine(x,y,dx,dy,me);
    const lineOpp = countLine(x,y,dx,dy,opp);
    score += scoreForLine(lineMe, true);
    score += scoreForLine(lineOpp, false) * 0.9; // blocking potential
  }
  // prefer center of activity
  score -= (Math.abs(x) + Math.abs(y)) * (difficulty==='easy'?0.02: difficulty==='normal'?0.01:0.005);
  // small randomness
  score += Math.random()*0.1;
  return score;

  function countLine(cx,cy,dx,dy,player){
    // returns {count, openEnds} if we place player at cx,cy
    let count = 1;
    let leftOpen = 0, rightOpen = 0;
    // forward
    for(let s=1;s<10;s++){
      const v = board.get(key(cx+dx*s, cy+dy*s));
      if(v===player) count++; else { if(v===undefined) rightOpen=1; break; }
    }
    for(let s=1;s<10;s++){
      const v = board.get(key(cx-dx*s, cy-dy*s));
      if(v===player) count++; else { if(v===undefined) leftOpen=1; break; }
    }
    return {count, openEnds: leftOpen + rightOpen};
  }
  function scoreForLine(line, isMe){
    const c = line.count, o = line.openEnds;
    // basic pattern weights
    if(c>=5) return 100000;
    if(c===4 && o>0) return isMe?20000:9000;
    if(c===3 && o===2) return isMe?8000:1800;
    if(c===3 && o===1) return isMe?1200:400;
    if(c===2 && o===2) return isMe?400:80;
    if(c===2 && o===1) return isMe?60:20;
    if(c===1) return 5;
    return 0;
  }
}

// pan buttons
document.querySelectorAll('.pan-btn').forEach(b=>{
  b.addEventListener('click', ()=>{
    const dx = parseInt(b.dataset.dx0), dy=parseInt(b.dataset.dy0);
    offsetX += dx * Math.max(1, Math.floor((gridSizeX||15)/3));
    offsetY += dy * Math.max(1, Math.floor((gridSizeY||15)/3));
    draw();
  });
});
document.getElementById('center').addEventListener('click', ()=>{ offsetX=0; offsetY=0; draw(); });

// new/undo
document.getElementById('new').addEventListener('click', ()=>resetGame());
document.getElementById('undo').addEventListener('click', ()=>undo());

// responsive canvas sizing
function resizeCanvas(){
  const wrap = document.getElementById('board-wrap');
  const rect = wrap.getBoundingClientRect();
  // pick square canvas
  const size = Math.min(rect.width-20, window.innerHeight - 160);
  const s = Math.max(320, Math.min(900, Math.floor(size)));
  canvas.width = s;
  canvas.height = s;
  // dynamic cell size for visual comfortable density:
  cellSize = Math.max(34, Math.floor(canvas.width / 15));
  draw();
}
window.addEventListener('resize', ()=>{ resizeCanvas(); });
resizeCanvas();
resetGame();

// optional keyboard support (desktop)
window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowLeft'){ offsetX -= 2; draw();}
  if(e.key==='ArrowRight'){ offsetX += 2; draw();}
  if(e.key==='ArrowUp'){ offsetY -= 2; draw();}
  if(e.key==='ArrowDown'){ offsetY += 2; draw();}
});

// simple helper: place a few stones for demo (commented)
// setStone(0,0,1); setStone(1,0,-1); setStone(0,1,1); draw();

</script>
</body>
</html>